#ifndef FILEAPI_H
#define FILEAPI_H

#include <stdio.h>

#include "types.h"

// Вычислить размер файла, Байт
#define calcFileSize(sizeofData, dataCount, sizeofPos) (dataCount * sizeofData + sizeofPos)

// Вычислить количество элементов данных исходя из размера файла
#define calcDataCount(fileSize, sizeofData, sizeofPos) ((fileSize - sizeofPos) / sizeofData)

// Структура блока данных
#pragma pack(push, 1)       // Задать выравнивание в структуре 1 байт
typedef struct {
    uint32 value;           // Значение
} DataBlock;
#pragma pack(pop)

typedef uint32 TPosition;        // Тип данных элемента позиции

/*!
 * \brief fileApi_writeDataToFile - записать массив данных db в файл filePath
 * - Процедура предназначена для записи массива данных в файл.
 * - Файл может существовать, а может и отсутствовать.
 * - Запись элементов в файл производится по кругу.
 * - Максимальное количество элементов в файле задаётся параметром maxCount.
 * - Если файл существует, то массив будет или дописан в конец файла,
 * или будут перезаписаны существующие данные.
 * - Обязательным требованием является наличие достаточного свободного
 * места на ПЗУ, где будет вестись файл.
 * - Количество элементов данных в массиве может быть
 * максимального количества элементов в файле.
 * - В случае ошибки, будет возвращено ненулевое значение,
 * идентифицируещее код ошибки работы процедуры.
 * \param filePath - путь и имя файла.
 * \param db - указатель на массив данных.
 * \param count - количество элементов массива данных.
 * \param maxCount - максимальное количество элементов данных в файле.
 * \return 0 - массив данных успешно записан,
 *        !0 - ошибка (значение - есть код ошибки).
 */
int fileApi_writeDataToFile(const char *filePath,
                             const DataBlock *db,
                             uint32 count,
                             uint32 maxCount);

/*!
 * \brief fileApi_readDataFromFile - прочитать массив данных из файла.
 * В целевой массив записываются данные, первый элемент по счету в котором
 * соответствует хронологически наиболее последнему записанному значению.
 * Так как файл записывается по кругу, то процедура может вернуть меньшее
 * количество прочитанных элементов, чем было запрошено.
 * Процедура не может вернуть большее кол-во элементов данных, чем содержится в файле.
 * Требования:
 * - Файл должен существовать.
 * - Формат файла должен быть корректным.
 * - Массив назначения должен быть инициализирован на всю величину
 * количества запрашиваемых элементов данных.
 * \param filePath - путь и имя файла.
 * \param db - указатель на целевой массив данных.
 * \param count - количество запрашиваемых элементов данных.
 * \param readCount - указатель на переменную,
 *                      для возвращения количества прочитанных элементов данных.
 * \return 0 - массив данных успешно заполнен,
 *        !0 - ошибка (значение - есть код ошибки)
 *        -1 - формат файла некорректен
 *
 * Если запрашиваемое кол-во элементов count равно 0, то процедура возвращает
 * код успешного выполнения 0, а кол-во прочитанных данных установит в *readCount = 0.
 */
int fileApi_readDataFromFile(const char *filePath,
                             DataBlock *db,
                             uint32 count,
                             uint32 *readCount);

/*!
 * \brief fileApi_writeData - записать массив данных в файл, с указанным
 * дескриптором f.
 * - Если данных для записи нет, то в файл ничего не пишется.
 * - Если количество элементов данных count больше, чем допустимо макс. размером файла maxCount,
 * то данные будут писаться по кругу, перетирая то, что было записано
 * в рамках текущего вызова процедуры.
 * \param f - дескриптор открытого на чтение и запись файла.
 * \param db - указатель на массив данных.
 * \param count - количество элементов массива данных.
 * \param maxCount - максимальное количество элементов данных в файле.
 * \return 0 - массив данных успешно записан,
 *        !0 - ошибка (значение - есть код ошибки)
 */
int fileApi_writeData(FILE *f,
                      const DataBlock *db,
                      uint32 count,
                      uint32 maxCount);

/*!
 * \brief fileApi_isValidFileFormat - процедура проверки корректности
 * формата файла.
 * \param f - дескриптор открытого файла на чтение.
 * \param maxCount - максимальное количество элементов данных в файле.
 * \return !0 - формат файла корректен
 *         0 - формат файла не корректен
 */
int fileApi_isValidFileFormat(FILE *f, uint32 maxCount);


// Получить размер файла.
// Файл должен быть открыт на чтение
// Возвращает размер в байтах.
// Если файл не открыт, или не удалось определить размер, то возвращает -1.
// Процедура сбивает текущую позицию файла.
long fileApi_getFileSize(FILE *f);

// Проверить, существует ли файл c указанным путём и наименованием filePath?
// Возвращает 1 - если существует, 0 - если не существует
int fileApi_isFileExists(const char *filePath);

#endif // FILEAPI_H
